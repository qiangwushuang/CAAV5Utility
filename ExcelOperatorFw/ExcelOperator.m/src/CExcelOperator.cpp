//===================================================================
// COPYRIGHT  2016/06/08
//===================================================================
// CExcelOperator.cpp
// Header definition of class CExcelOperator
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2016/06/08 Creation: Code generated by the 3DS wizard
//===================================================================
#ifndef UNICODE 
#define UNICODE
#endif
#ifndef _UNICODE 
#define _UNICODE
#endif
#include "CExcelOperator.h"

#include "CHyperlink.h"
#include "CHyperlinks.h"

#include <tchar.h>
#include <comdef.h>

//-----------------------------------------------------------------------------
// CExcelOperator : constructor
//-----------------------------------------------------------------------------
CExcelOperator::CExcelOperator()
{
	strFilePath       = _T("");
	bFileOpened       = false;
}

//-----------------------------------------------------------------------------
// CExcelOperator : destructor
//-----------------------------------------------------------------------------

CExcelOperator::~CExcelOperator()
{
	if (bFileOpened)
	{
		Close();
	}
}

CString CExcelOperator::GetAppPath()
{
	TCHAR lpFileName[MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(),lpFileName,MAX_PATH);

	CString strFileName = lpFileName;
	int nIndex = strFileName.ReverseFind ('\\');

	CString strPath;

	if (nIndex > 0)
		strPath = strFileName.Left (nIndex);
	else
		strPath = "";
	return strPath;
}

BOOL CExcelOperator::Open()
{
	LPDISPATCH lpDisp=NULL;
	COleVariant covOptional((long)DISP_E_PARAMNOTFOUND,VT_ERROR);   
	CoInitialize(NULL);
 	if (!MyApp.CreateDispatch(_T("Excel.Application"),NULL))	//打开Excel
 	{
 		AfxMessageBox(_T("EXCEL初始化时出错!"),MB_OK|MB_ICONERROR);
 		Exit();
 		return FALSE;
 	}
	lpDisp=MyApp.get_Workbooks();	//得到workbooks
	MyBooks.AttachDispatch(lpDisp,TRUE);
	lpDisp = MyBooks.Add(covOptional);	//得到workbook
	MyBook.AttachDispatch(lpDisp,TRUE);
	lpDisp=MyBook.get_Worksheets();		//得到worksheets
	MySheets.AttachDispatch(lpDisp,TRUE);
	// 	MySheets.get_Worksheet();
	bFileOpened = true;
	return TRUE;
}

BOOL CExcelOperator::Close()
{
	COleVariant savsChanges((short)TRUE);
	COleVariant	covOptional((long)DISP_E_PARAMNOTFOUND,VT_ERROR); 
	MyRange.ReleaseDispatch();
	WorkSheet.ReleaseDispatch();
	MySheets.ReleaseDispatch();
	//这里的saveChanges决定了关闭时，是否保存之前做的修改。
	MyBook.Close(savsChanges,_variant_t(strFilePath),covOptional);
	MyBook.ReleaseDispatch();
	MyBooks.Close();
	MyBooks.ReleaseDispatch();
	MyApp.Quit();
	MyApp.ReleaseDispatch();
	CoUninitialize();

	return true;
}
BOOL CExcelOperator::Open(CString strFile)
{
	LPDISPATCH   lpDisp=NULL;
	CoInitialize(NULL);
	if (!MyApp.CreateDispatch(_T("Excel.Application"),NULL))
	{
		AfxMessageBox(_T("EXCEL初始化时出错!"),MB_OK|MB_ICONERROR);
		Exit();
		return FALSE;
	}
	lpDisp=MyApp.get_Workbooks();
	MyBooks.AttachDispatch(lpDisp,TRUE);
	lpDisp = MyBooks.Open(strFile, vtMissing, vtMissing, vtMissing, 
		vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing, vtMissing,vtMissing);
	MyBook.AttachDispatch(lpDisp,TRUE);
	lpDisp=MyBook.get_Worksheets(); 
	MySheets.AttachDispatch(lpDisp,TRUE);
	strFilePath = strFile;

	bFileOpened = true;
	return TRUE;
}

BOOL CExcelOperator::OpenSheet(CString strSheet)
{
	LPDISPATCH  lpDisp=NULL;
	long len;
	len=MySheets.get_Count();
	for(long i=1;i<=len;i++)
	{
		lpDisp=MySheets.get_Item((_variant_t)(long)i);
		WorkSheet.AttachDispatch(lpDisp,TRUE);
		CString str=WorkSheet.get_Name();
		if(WorkSheet.get_Name()==strSheet)
		{
			lpDisp=WorkSheet.get_Cells();
			MyRange.AttachDispatch(lpDisp,TRUE);
			return TRUE;
		}
	}
	return FALSE;
}

bool CExcelOperator::OpenSheet(int i)
{
	LPDISPATCH  lpDisp=NULL;
	long len;
	len=MySheets.get_Count();
	lpDisp=MySheets.get_Item((_variant_t)(long)i);
	WorkSheet.AttachDispatch(lpDisp,TRUE);
	lpDisp=WorkSheet.get_Cells();
	MyRange.AttachDispatch(lpDisp,TRUE);
	return true;
}

CString CExcelOperator::GetCurrentSheetName()
{
	return WorkSheet.get_Name();
}

bool CExcelOperator::GetSheetsCount(int& sheetcount)
{
	sheetcount = MySheets.get_Count();
	return true;
}

bool CExcelOperator::SetCurrentSheetName(CString sheetname)
{
	WorkSheet.put_Name(sheetname);
	return true;
}

BOOL CExcelOperator::SetItemText(long Row,long Col,CString strText)
{
	long lRow=0,lCol=0;
	lRow=GetRowS();
	lCol=GetColS();
	if(Row>lRow ||Col>lCol)
	{
		CString strText;
		strText.Format(_T("由于(%d,%d)已经超过了(%d,%d)的范围,所以在(%d,%d)设置失败!")
			,Row,Col,lRow,lCol,Row,Col);
		AfxMessageBox(strText,MB_OK|MB_ICONERROR);
		return FALSE;
	}
	MyRange.put_Item(_variant_t(Row), _variant_t(Col), _variant_t(strText));
	return TRUE;
}

CString CExcelOperator::GetItemText(long Row,long Col)
{
	CString strValue=_T("");
	long lRow=0,lCol=0;
	lRow=GetRowS();
	lCol=GetColS();
	if(Row>lRow ||Col>lCol)
	{
		CString strText;
		strText.Format(_T("由于(%d,%d)已经超过了(%d,%d)的范围,所以返回空值")
			,Row,Col,lRow,lCol,Row,Col);
		AfxMessageBox(strText,MB_OK|MB_ICONERROR);
		return strValue;
	}
	VARIANT lpDisp=MyRange.get_Item(_variant_t(Row), _variant_t(Col));
	CRange rgRgeValue;
	rgRgeValue.AttachDispatch(lpDisp.pdispVal, TRUE);
	_variant_t vtVal = rgRgeValue.get_Value();
	if (vtVal.vt == VT_EMPTY)
	{
		rgRgeValue.ReleaseDispatch();
		strValue = _T("");
		rgRgeValue.ReleaseDispatch();
		return strValue;
	}
	vtVal.ChangeType(VT_BSTR);
	strValue= vtVal.bstrVal;
	rgRgeValue.ReleaseDispatch();
	return strValue;
}

void CExcelOperator::SaveAs(CString strPath)
{
	if(IsFileExist(strPath,FALSE)==TRUE)
		DeleteFile(strPath);
	MyBook.SaveAs(_variant_t(strPath),vtMissing,vtMissing,vtMissing,vtMissing,vtMissing
		,0,vtMissing,vtMissing,vtMissing,vtMissing);
	strFilePath=strPath;
	//	AfxMessageBox(_T("Excel保存成功"),MB_OK|MB_ICONINFORMATION);
}

void CExcelOperator::Save()
{
	MyBook.Save();
	//	AfxMessageBox(_T("Excel保存成功"),MB_OK|MB_ICONINFORMATION);
}

void CExcelOperator::AddSheet(CString strSheet)
{
	//COleVariant temp;
	//LPDISPATCH  pdisSheetNext = NULL;
	////LPDISPATCH  currentRange;
	//CWorksheet  sheetNext;
	//temp.pdispVal = WorkSheet.m_lpDispatch;
	//temp.vt = VT_DISPATCH;
	////如果已经有名字为sheetName的sheet，则先将其删除
	//DeleteSheet(strSheet);
	//
	LPDISPATCH  lpDisp=NULL;
	lpDisp=MySheets.Add(vtMissing, vtMissing,vtMissing,vtMissing);

	WorkSheet.AttachDispatch(lpDisp,TRUE);
	WorkSheet.put_Name(strSheet);
	lpDisp=WorkSheet.get_Cells();
	MyRange.AttachDispatch(lpDisp,TRUE);
}

void CExcelOperator::GetRange(CString strBegin,CString strEnd)
{
	MyRange=WorkSheet.get_Range(_variant_t(strBegin),_variant_t(strEnd));
}

void CExcelOperator::AutoColFit()
{
	CRange rg=MyRange.get_EntireColumn();
	rg.AutoFit();
	rg.ReleaseDispatch();
}

void CExcelOperator::AutoRowFit()
{
	CRange rg=MyRange.get_EntireRow();
	rg.AutoFit();	
	rg.ReleaseDispatch();
}

void CExcelOperator::SetWrapText(BOOL blnTrue)
{
	MyRange.put_WrapText((_variant_t)(short)blnTrue);
}

void CExcelOperator::SetVisible(BOOL blnVisible)
{
	if(blnVisible==TRUE)
		if(strFilePath!="")
		{
			if(IsFileExist(strFilePath,FALSE))
			{
				Exit();
				ShellExecute(NULL,_T("open"),strFilePath,NULL,NULL,SW_SHOW);
			}
			else
			{
				CString strName;
				strName="路径"+strFilePath+"错误,不能打开显示!";
				AfxMessageBox(strFilePath,MB_OK|MB_ICONINFORMATION);
			}
		}
		else
		{
			AfxMessageBox(_T("请先存文件后,方可打开!"),MB_OK|MB_ICONINFORMATION);
		}
}

void CExcelOperator::SetFont(MyFont font)
{
	CExcelFont f=MyRange.get_Font();
	f.SetName(_variant_t(font.Name));
	f.SetShadow((_variant_t)(short)font.Shadow);
	f.SetSize((_variant_t)(short)font.size);
	f.SetUnderline((_variant_t)(short)font.Underline);
	f.SetBold((_variant_t)(short)font.Bold);
	f.SetColor((_variant_t)(long)font.ForeColor);
	f.SetItalic((_variant_t)(short)font.Italic);
	f.SetStrikethrough((_variant_t)(short)font.Strikethrough);
	f.SetSubscript((_variant_t)(short)font.Subscript);
	f.SetSuperscript((_variant_t)(short)font.Subscript);
	f.ReleaseDispatch();
}

void CExcelOperator::SetAlignment(MyAlignment XMyAlignment)
{
	MyRange.put_HorizontalAlignment((_variant_t)(short)XMyAlignment.HorizontalAlignment);
	MyRange.put_VerticalAlignment((_variant_t)(short)XMyAlignment.VerticalAlignment);
}

void CExcelOperator::GetAllRange()
{
	LPDISPATCH  lpDisp=NULL;
	lpDisp=WorkSheet.get_Cells();
	MyRange.AttachDispatch(lpDisp,TRUE);
}

void CExcelOperator::SetMergeCells(BOOL blnTrue)
{
	if(blnTrue==TRUE)
	{
		int i,j;
		long Row=GetRowS();
		long Col=GetColS();
		for(j=2;j<=Col;j++) SetItemText(1,j,"");
		for(i=2;i<=Row;i++)
			for(j=1;j<=Col;j++)
				SetItemText(i,j,"");
	}
	MyRange.put_MergeCells((_variant_t)(short)blnTrue);
}

void CExcelOperator::SetBackStyle(MyBackStyle BackStyle)
{
	LPDISPATCH  lpDisp=NULL;
	CInterior Itor;
	lpDisp=MyRange.get_Interior();
	Itor.AttachDispatch(lpDisp,TRUE);
	if(BackStyle.transparent==TRUE)
		Itor.SetColorIndex((_variant_t)(short)xlNone);
	else
	{
		Itor.SetColor((_variant_t)(long)BackStyle.Color);
		Itor.SetPattern((_variant_t)(short)BackStyle.Pattern);
		Itor.SetPatternColor((_variant_t)(long)BackStyle.PatternColor);
	}
	Itor.ReleaseDispatch();

}

void CExcelOperator::SetBorderLine(short Xposition,MyBorder XBorder)
{
	long Row,Col;
	Row=GetRowS();
	Col=GetColS();
	if(Row==1)
		if(Xposition==xlInsideHorizontal) return;
	if(Col==1)
		if(Xposition==xlInsideVertical) return;
	LPDISPATCH  lpDisp=NULL;
	lpDisp=MyRange.get_Borders();   
	CBorders   bds;   
	bds.AttachDispatch(lpDisp);   
	CBorder   bd;   
	lpDisp=bds.get_Item((long)Xposition);   
	bd.AttachDispatch(lpDisp);
	bd.put_LineStyle((_variant_t)(short)XBorder.LineStyle);
	bd.put_Color((_variant_t)(long)XBorder.Color);
	bd.put_Weight((_variant_t)(short)XBorder.Weight);
	bd.ReleaseDispatch();
	bds.ReleaseDispatch();
}

long CExcelOperator::GetRowS()
{
	long len=0;
	CRange rg=MyRange.get_EntireRow();	
	len=rg.get_Count();
	rg.ReleaseDispatch();
	return len;
}

long CExcelOperator::GetUsedRows()
{
	long len=0;
	CRange usedRange;
	CRange usedRowsRange;
	usedRange.AttachDispatch(WorkSheet.get_UsedRange());
	usedRowsRange.AttachDispatch(usedRange.get_Rows());

	len = usedRowsRange.get_Count();
	usedRowsRange.ReleaseDispatch();
	usedRange.ReleaseDispatch();

	return len;
}

long CExcelOperator::GetColS()
{
	long len=0;
	CRange rg=MyRange.get_EntireColumn();
	len=rg.get_Count();
	rg.ReleaseDispatch();
	return len;
}

long CExcelOperator::GetUsedCols()
{
	long len=0;
	CRange usedRange;
	CRange usedColsRange;

	usedRange.AttachDispatch(WorkSheet.get_UsedRange());
	usedColsRange.AttachDispatch(usedRange.get_Columns());

	len = usedColsRange.get_Count();
	usedColsRange.ReleaseDispatch();
	usedRange.ReleaseDispatch();

	return len;
}

void CExcelOperator::SetNumberFormat(MyNumberFormat XNumberFormat)
{
	CString strText=XNumberFormat.strValue;
	MyRange.put_NumberFormat(_variant_t(strText));
}

void CExcelOperator::SetColumnWidth(int intWidth)
{
	double f=intWidth;
	MyRange.put_ColumnWidth((_variant_t)(double)f);
}

void CExcelOperator::SetRowHeight(int intHeight)
{
	double f=intHeight;
	MyRange.put_RowHeight((_variant_t)(double)f);
}

void CExcelOperator::InsertPicture(CString iStartCell,CString iEndCell,CString strFilePath)
{
	LPDISPATCH  lpDisp=NULL;
	if(IsFileExist(strFilePath,FALSE))
	{
		//	lpDisp=WorkSheet.get
		CShapes	pShapes;
		pShapes.AttachDispatch(WorkSheet.get_Shapes());
		CRange range = WorkSheet.get_Range(COleVariant(iStartCell),COleVariant(iEndCell));
		VARIANT rLeft = range.get_Left();
		VARIANT rTop = range.get_Top();
		VARIANT rWidth = range.get_Width();
		VARIANT rHeight = range.get_Height();
		long msoFalse = 1, msoTrue = 1;
		CShape pShape = pShapes.AddPicture(strFilePath, msoFalse, msoTrue,
			(float)rLeft.dblVal+1, (float)rTop.dblVal+1, (float)rWidth.dblVal-1, (float)rHeight.dblVal-1);
		//CShapeRange shapeRange = pShapes.get_Range(_variant_t(long(1)));
		//shapeRange.put_Height((float)rHeight.dblVal);
		//shapeRange.put_Width((float)rWidth.dblVal);


		//shapeRange.ReleaseDispatch();
		pShape.ReleaseDispatch();
		pShapes.ReleaseDispatch();
	}
}

void CExcelOperator::SetBackPicture(CString strFilePath)
{
	if(IsFileExist(strFilePath,FALSE)==TRUE)
		WorkSheet.SetBackgroundPicture(strFilePath);
}

void CExcelOperator::PrintOut(short CopySum)
{
	if(CopySum<=0) CopySum=1;
	COleVariant covTrue((short)TRUE); 
	COleVariant covFalse((short)FALSE); 
	COleVariant	covOptional((long)DISP_E_PARAMNOTFOUND,VT_ERROR); 
	WorkSheet.PrintOut(vtMissing,vtMissing,(_variant_t)(short)CopySum,vtMissing
		,vtMissing,vtMissing,covTrue,vtMissing);
}

void CExcelOperator::PrePrintOut(BOOL blnEnable)
{
	COleVariant covOptional((short)blnEnable);
	WorkSheet.PrintPreview(covOptional);
}

BOOL CExcelOperator::IsFileExist(CString strFn, BOOL bDir)
{
	HANDLE h;
	LPWIN32_FIND_DATA pFD=new WIN32_FIND_DATA;
	BOOL bFound=FALSE;
	if(pFD)
	{
		h=FindFirstFile(strFn,pFD);
		bFound=(h!=INVALID_HANDLE_VALUE);
		if(bFound)
		{
			if(bDir)
				bFound= (pFD->dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)!=NULL;
			FindClose(h);
		}
		delete pFD;
	}
	return bFound;
}

BOOL CExcelOperator::QueryPosition(CString QueryValue,long &Row,long &Col)
{
	BOOL bFound = FALSE;
	long lRow=0,lCol=0;
	lRow=GetUsedRows();
	lCol=GetUsedCols();
	for (int i=1;i<=lCol;i++)
	{
		for (int j=1;j<=lRow;j++)
		{
			//这里默认查找5000次就认为没有查到，避免时间太长
			if (i*j > 5000)
			{
				return FALSE;
			}
			if (GetItemText(j,i)==QueryValue)
			{
				Col = i;
				Row = j;
				return TRUE;
			}
		}
	}

	return FALSE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::numberConvertToLetterInExcel
// 参数：
//    - long number      数字列号,必须是从1开始
//    - CString &letter  字母列号
// 返回：
//     BOOL
// 说明：将列号转化成对应的excel表中对应的字母,相当于是10进制向26进制的转化
//       A就相当于0，Z就相当于25
//-----------------------------------------------------------
BOOL CExcelOperator::numberConvertToLetterInExcel(long number,CString &letter)
{
	CString strLettersLib("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	int     iIndex;                //得到的字母列号最后一个字母在A-Z之间的索引值

	if (number <= 0)
	{
		return FALSE;
	}
	do 
	{
		number--;
		iIndex  = number % 26;
		number  = number / 26;
		letter += CString(strLettersLib.GetAt(iIndex));
	} while(number > 0);
	letter.MakeReverse();

	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::ReadRow
// 参数：
//    - CStringArray &RowValues
//    - long row                要读取的行号，默认读取第一行
// 返回：
//     BOOL
// 说明：该函数适合读取的行应有如下条件：
//       1.从第一列开始读取 2.从开始处往后不应有空单元格，遇到空单元格默认结束
//       另外需要说明的是：该类里面的读取函数在读的过程中都已经将每个单元格中值得空格“”消除了。
//-----------------------------------------------------------
BOOL CExcelOperator::ReadRow(CStringArray &RowValues, long row )
{
	CRange      oRange;
	CString     sStartingCell("A");
	COleVariant covOptional(DISP_E_PARAMNOTFOUND,VT_ERROR);
	long        iColsWidth;
	CString     tempCellValue;         //临时单元格的字符串，判断该单元格是不是为空，若为空则结束
	char        buffer[20];

	long        iRows;                 //存储读取区域的大小
	long        iCols;
	long        index[2];              //遍历OLE数组的索引值
	COleVariant vData;                 //存储OLE数组中的值

	iColsWidth   = 12;
	tempCellValue= GetItemText(row,iColsWidth);
	tempCellValue.Remove(' ');
	while (tempCellValue != CString(""))
	{
		//如果检测到当前读取区域的宽度不够，则每次增加宽度2再进行检测
		iColsWidth    += 2;
		tempCellValue  = GetItemText(row,iColsWidth);
		tempCellValue.Remove(' ');
	}
	//先清空
	RowValues.RemoveAll();
	_itoa(row,buffer,10);
	sStartingCell += CString(buffer);

	//先判断是否已经链接到Excel
	if (MyApp.m_lpDispatch== NULL)
	{
		return FALSE;
	}
	oRange = WorkSheet.get_Range(COleVariant(sStartingCell),covOptional);
	oRange = oRange.get_Resize(COleVariant((short)1),COleVariant((short)iColsWidth));
	// Get the data.
	COleSafeArray saRet(oRange.get_Value());
	saRet.GetUBound(1, &iRows);
	saRet.GetUBound(2, &iCols);
	ASSERT(iRows==1);
	for (int iRowCounter=1;iRowCounter<=iRows;iRowCounter++)
	{
		for (int iColCounter=1;iColCounter<=iCols;iColCounter++)
		{
			index[0] = iRowCounter;
			index[1] = iColCounter;
			saRet.GetElement(index,vData);
			
			RowValues.Add(CString(vData));
			
		}
	}
	return TRUE;
}

//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::ReadRowEx
// 参数：
//    - CStringArray &RowValues
//    - long row
// 返回：
//     BOOL
// 说明：与上面不同的是，在设置的读取区域内，不管读取得到的
//       是不是为空，都要返回，而上面的是将空值过滤掉了。
//-----------------------------------------------------------
BOOL CExcelOperator::ReadRowEx(CStringArray &RowValues,long row)
{
	CRange      oRange;
	CString     sStartingCell("A");
	COleVariant covOptional(DISP_E_PARAMNOTFOUND,VT_ERROR);
	long        iColsWidth;
	CString     tempCellValue;         //临时单元格的字符串，判断该单元格是不是为空，若为空则结束
	char        buffer[20];

	long        iRows;                 //存储读取区域的大小
	long        iCols;
	long        index[2];              //遍历OLE数组的索引值
	COleVariant vData;                 //存储OLE数组中的值

	iColsWidth   = 12;
	tempCellValue= GetItemText(row,iColsWidth);
	tempCellValue.Remove(' ');
	while (tempCellValue != CString(""))
	{
		//如果检测到当前读取区域的宽度不够，则每次增加宽度2再进行检测
		iColsWidth    += 2;
		tempCellValue  = GetItemText(row,iColsWidth);
		tempCellValue.Remove(' ');
	}
	//先清空
	RowValues.RemoveAll();
	_itoa(row,buffer,10);
	sStartingCell += CString(buffer);

	//先判断是否已经链接到Excel
	if (MyApp.m_lpDispatch== NULL)
	{
		return FALSE;
	}
	oRange = WorkSheet.get_Range(COleVariant(sStartingCell),covOptional);
	oRange = oRange.get_Resize(COleVariant((short)1),COleVariant((short)iColsWidth));
	// Get the data.
	COleSafeArray saRet(oRange.get_Value());
	saRet.GetUBound(1, &iRows);
	saRet.GetUBound(2, &iCols);
	ASSERT(iRows==1);
	for (int iRowCounter=1;iRowCounter<=iRows;iRowCounter++)
	{
		for (int iColCounter=1;iColCounter<=iCols;iColCounter++)
		{
			index[0] = iRowCounter;
			index[1] = iColCounter;
			saRet.GetElement(index,vData);
			CString szdata(vData);
			szdata.Remove(' ');
			RowValues.Add(szdata);
		}
	}
	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::ReadRow
// 参数：
//    - CStringArray &strRowValues
//    - long row         要读取的行号
//    - long colBegin    要读取行的开始列索引值
//    - long colEnd      要读取行的结束列索引值
// 返回：
//     BOOL
// 说明：该函数的存在是为了弥补上一个函数的不足之处，满足最一般的excel读取要求
//     
//-----------------------------------------------------------
BOOL CExcelOperator::ReadRow(CStringArray &strRowValues, long row, long colBegin, long colEnd)
{
	return TRUE;
}

//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::WriteRow
// 参数：
//    - CStringArray &strRowValues  要写入的数据
//    - long row                    写入行的行索引值
// 返回：
//     BOOL
// 说明：从写入行的第一列开始向其中写数据
//     
//-----------------------------------------------------------
BOOL CExcelOperator::WriteRow(CStringArray &strRowValues,long row)
{
	CRange  oRange;
	CString strStartingCell("A");
	char    buffer[20];

	_itoa(row,buffer,10);
	strStartingCell += CString(buffer);
	if (MyApp.m_lpDispatch == NULL)
	{
		return FALSE;
	}
	oRange = WorkSheet.get_Range(COleVariant(strStartingCell),COleVariant(strStartingCell));
	oRange = oRange.get_Resize(COleVariant((short)1),COleVariant((short)strRowValues.GetSize()));
	//Create the SAFEARRAY.
	COleSafeArray saRet;
	DWORD numElements[2];
	numElements[0]= 1;                        //Number of rows in the range.
	numElements[1]= strRowValues.GetSize();   //Number of columns in the range.
	saRet.Create(VT_BSTR, 2, numElements);

	//Fill the SAFEARRAY
	long index[2];
	for (long lRowCounter=0;lRowCounter<1;lRowCounter++)
	{
		for (long lColCounter=0;lColCounter<strRowValues.GetSize();lColCounter++)
		{
			index[0] = lRowCounter;
			index[1] = lColCounter;
			VARIANT v;
			VariantInit(&v);
			v.vt = VT_BSTR;
			v.bstrVal = strRowValues[lColCounter].AllocSysString();
			saRet.PutElement(index, v.bstrVal);
			SysFreeString(v.bstrVal);
			VariantClear(&v);
		}
	}
	//Set the range value to the SAFEARRAY.
	oRange.put_Value(COleVariant(saRet));
	saRet.Detach();
	//Return control of Excel to the user.
	//MyApp.put_Visible(TRUE);
	//MyApp.put_UserControl(TRUE);

	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::WriteRow
// 参数：
//    - CStringArray &strRowValues 要写入的数据
//    - long row                   写入行的索引值
//    - long colBegin              写入行开始写入数据的列索引值
// 返回：
//     BOOL
// 说明：可以在任意位置写入数据
//     
//-----------------------------------------------------------
BOOL CExcelOperator::WriteRow(CStringArray &strRowValues,long row,long colBegin)
{
	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::ReadColumn
// 参数：
//    - CStringArray &strColValues
//    - long col     要读取的列的列号
// 返回：
//     BOOL
// 说明：该函数适合读取的列应有如下条件：
//       1.从第一行开始读取 2.从开始处往后不应有空单元格，遇到空单元格默认结束
//     
//-----------------------------------------------------------
BOOL CExcelOperator::ReadColumn(CStringArray &strColValues,long col)
{
	CRange      oRange;
	CString     sStartingCell;
	COleVariant covOptional(DISP_E_PARAMNOTFOUND,VT_ERROR);
	long        iRowsWidth;
	CString     tempCellValue;         //临时单元格的字符串，判断该单元格是不是为空，若为空则结束
	char        buffer[20];

	long        iRows;                 //存储读取区域的大小
	long        iCols;
	long        index[2];              //遍历OLE数组的索引值
	COleVariant vData;                 //存储OLE数组中的值

	iRowsWidth   = 5;
	tempCellValue= GetItemText(iRowsWidth,col);
	tempCellValue.Remove(' ');
	while (tempCellValue != CString(""))
	{
		iRowsWidth   += 5;
		tempCellValue = GetItemText(iRowsWidth,col);
		tempCellValue.Remove(' ');
	}
	strColValues.RemoveAll();
	if (!numberConvertToLetterInExcel(col,sStartingCell))
	{
		return FALSE;
	}
	_itoa(1,buffer,10);
	sStartingCell += CString(buffer);

	//先判断是否已经链接到Excel
	if (MyApp.m_lpDispatch== NULL)
	{
		return FALSE;
	}
	oRange = WorkSheet.get_Range(COleVariant(sStartingCell),covOptional);
	oRange = oRange.get_Resize(COleVariant((short)iRowsWidth),COleVariant((short)1));
	// Get the data.
	COleSafeArray saRet(oRange.get_Value());
	saRet.GetUBound(1, &iRows);
	saRet.GetUBound(2, &iCols);
	ASSERT(iCols==1);
	for (int iRowCounter=1;iRowCounter<=iRows;iRowCounter++)
	{
		for (int iColCounter=1;iColCounter<=iCols;iColCounter++)
		{
			index[0] = iRowCounter;
			index[1] = iColCounter;
			saRet.GetElement(index,vData);
			CString szdata(vData);
			szdata.Remove(' ');
			if (szdata != CString(""))
			{
				strColValues.Add(szdata);
			}
		}
	}
	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::ReadColumn
// 参数：
//    - CStringArray &strColValues
//    - long col        要读取列的列号
//    - long rowBegin   要读取列的开始单元格的行索引值
//    - long rowEnd     要读取列的结束单元格的行索引值
// 返回：
//     BOOL
// 说明：该函数的存在是为了弥补上一个函数的不足之处，满足最一般的excel列读取要求
//     
//-----------------------------------------------------------
BOOL CExcelOperator::ReadColumn(CStringArray &strColValues,long col,long rowBegin,long rowEnd)
{
	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::WriteColumn
// 参数：
//    - CStringArray &strColValues 要写入的数据
//    - long col                   写入列的索引值
// 返回：
//     BOOL
// 说明：从写入列的第一行开始向其中写数据
//     
//-----------------------------------------------------------
BOOL CExcelOperator::WriteColumn(CStringArray &strColValues,long col)
{
	CRange  oRange;
	CString strStartingCell;
	char    buffer[20];

	if (!numberConvertToLetterInExcel(col,strStartingCell))
	{
		return FALSE;
	}
	_itoa(1,buffer,10);
	strStartingCell += CString(buffer);
	if (MyApp.m_lpDispatch == NULL)
	{
		return FALSE;
	}
	oRange = WorkSheet.get_Range(COleVariant(strStartingCell),COleVariant(strStartingCell));
	oRange = oRange.get_Resize(COleVariant((short)strColValues.GetSize()),COleVariant((short)1));
	//Create the SAFEARRAY.
	COleSafeArray saRet;
	DWORD numElements[2];
	numElements[0]= strColValues.GetSize(); //Number of rows in the range.
	numElements[1]= 1;                      //Number of columns in the range.
	saRet.Create(VT_BSTR, 2, numElements);

	//Fill the SAFEARRAY
	long index[2];
	for (long lColCounter=0;lColCounter<1;lColCounter++)
	{
		for (long lRowCounter=0;lRowCounter<strColValues.GetSize();lRowCounter++)
		{
			index[0] = lRowCounter;
			index[1] = lColCounter;
			VARIANT v;
			VariantInit(&v);
			v.vt = VT_BSTR;
			v.bstrVal = strColValues[lRowCounter].AllocSysString();
			saRet.PutElement(index, v.bstrVal);
			SysFreeString(v.bstrVal);
			VariantClear(&v);
		}
	}
	//Set the range value to the SAFEARRAY.
	oRange.put_Value(COleVariant(saRet));
	saRet.Detach();
	//Return control of Excel to the user.
	//MyApp.put_Visible(TRUE);
	//MyApp.put_UserControl(TRUE);

	return TRUE;
}
//-----------------------------------------------------------
// 函数名称：
//     CExcelOperator::WriteColumn
// 参数：
//    - CStringArray &strColValues 要写入的数据
//    - long col                   写入列的索引值
//    - long rowBegin              写入列开始写入数据单元格的行索引值
// 返回：
//     BOOL
// 说明：可以在任意位置按列写入数据
//     
//-----------------------------------------------------------
BOOL CExcelOperator::WriteColumn(CStringArray &strColValues,long col,long rowBegin)
{
	return TRUE;
}

BOOL CExcelOperator::CopySheet(CString sheetName)
{
	COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR);
	COleVariant temp;
	LPDISPATCH  pdisSheetNext = NULL;
	//LPDISPATCH  currentRange;
	CWorksheet  sheetNext;
	temp.pdispVal = WorkSheet.m_lpDispatch;
	temp.vt = VT_DISPATCH;
	//如果已经有名字为sheetName的sheet，则先将其删除
	DeleteSheet(sheetName);

	WorkSheet.Copy(vOpt,temp);

	pdisSheetNext = WorkSheet.get_Next();
	sheetNext.AttachDispatch(pdisSheetNext,TRUE);
	//这里是处理：当前sheet的下一个就是隐藏工作表的情况
	while (!sheetNext.get_Visible())
	{
		pdisSheetNext = sheetNext.get_Next();
		sheetNext.AttachDispatch(pdisSheetNext,TRUE);
	}
	sheetNext.put_Name((LPCTSTR)sheetName);

	//这里一定要用DetachDispatch而不是ReleaseDispatch，因为之前在前面设置了
	//release为auto，并且的temp引用了WorkSheet.m_lpDispatch，所以如果这里
	//调用ReleaseDispatch，其会释放该接口指针，但是在temp又要释放一次
	//从而导致内存访问出错。
	temp.pdispVal = NULL;
	//WorkSheet.DetachDispatch();
	//WorkSheet.AttachDispatch(pdisSheetNext,TRUE);
	//
	////当已经存在sheetName时，还要调用put_Name，程序出错。
	//WorkSheet.put_Name((LPCTSTR)sheetName);
	//currentRange = WorkSheet.get_Cells();
	//MyRange.ReleaseDispatch();
	//MyRange.AttachDispatch(currentRange,TRUE);

	return TRUE;
}
BOOL CExcelOperator::DeleteSheet(CString sheetName)
{
	long        sheetNum = 0;
	CWorksheet  tempSheet;

	sheetNum = MySheets.get_Count();
	for (int i=1;i<=sheetNum;i++)
	{
		tempSheet.AttachDispatch(MySheets.get_Item((_variant_t)(long)i),TRUE);
		//如果是sheet表是隐藏的话，就跳过，不做任何处理
		if (tempSheet.get_Visible()&&sheetName == tempSheet.get_Name())
		{
			//删除的是当前的工作表
			if (WorkSheet.get_Name()==sheetName)
			{
				//如果这是最后一张表
				if (1==sheetNum)
				{
					WorkSheet.AttachDispatch(NULL,TRUE);
					MyRange.AttachDispatch(NULL,TRUE);
				}
				else
				{
					//将当前的工作表设为sheetName的前一张或是后一张表,(前一张优先)
					WorkSheet.AttachDispatch(MySheets.get_Item((_variant_t)(i==1?++i:--i)),TRUE);
					MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);
				}
			}
			//设置系统不显示确认对话框，在操作Excel时，由于excel可能没有打开，
			//显示确认对话框可能出错
			MyApp.put_DisplayAlerts(FALSE);
			tempSheet.Delete();
			MyApp.put_DisplayAlerts(TRUE);
			break;
		}
		//tempSheet.ReleaseDispatch();
	}

	return TRUE;
}
BOOL CExcelOperator::GetSheetName(long index,CString &sheetName)
{
	long       sheetCount   = 0;
	long       indexVisible = 0; //只是可见的sheet表的索引
	CWorksheet tempSheet; 
	if (MySheets.m_lpDispatch==NULL)
	{
		return FALSE;
	}
	sheetCount = MySheets.get_Count();//这里返回的数量包含了隐藏的sheet表
	if (sheetCount < 1||index > sheetCount||index < 0)
	{
		return FALSE;
	}
	if (index == 0)
	{
		sheetName = WorkSheet.get_Name();
		return TRUE;
	}
	else
	{
		for (int i=1;i<=sheetCount;i++)
		{
			tempSheet.AttachDispatch(MySheets.get_Item(_variant_t(i)),TRUE);
			if (tempSheet.get_Visible())
			{
				indexVisible++;
			}
			if (index == indexVisible)
			{
				sheetName = tempSheet.get_Name();
				return TRUE;
			}
		}
		return FALSE;
	}
}

BOOL CExcelOperator::MoveToNextSheet()
{
	LPDISPATCH  pdisSheetNext = NULL;
	LPDISPATCH  pdisRangeNext = NULL;
	CWorksheet  sheetNext;

	pdisSheetNext = WorkSheet.get_Next();
	sheetNext.AttachDispatch(pdisSheetNext,TRUE);
	if (NULL == pdisSheetNext)
	{
		return FALSE;
	}
	else
	{
		//处理有sheet表隐藏的情况
		while (pdisSheetNext!=NULL&&!sheetNext.get_Visible())
		{
			pdisSheetNext = sheetNext.get_Next();
			sheetNext.AttachDispatch(pdisSheetNext,TRUE);
		}
		//将sheetNext的指针属性设为NULL,由于其是自动释放，避免函数结束时将pdisSheetNext指向
		//的接口释放，从而导致外面的WorkSheet不能用
		//-------------------关键-----------------//
		sheetNext.m_lpDispatch = NULL;
		//-------------------关键-----------------//
		if (pdisSheetNext==NULL)
		{
			return FALSE;
		}
		else
		{
			WorkSheet.AttachDispatch(pdisSheetNext,TRUE);
			pdisRangeNext = WorkSheet.get_Cells();
			MyRange.AttachDispatch(pdisRangeNext,TRUE);
			return TRUE;
		}
	}
}
void CExcelOperator::Exit()
{
	COleVariant saveChanges((short)TRUE);
	COleVariant	covOptional((long)DISP_E_PARAMNOTFOUND,VT_ERROR); 
	MyRange.ReleaseDispatch();
	WorkSheet.ReleaseDispatch();
	MySheets.ReleaseDispatch();
	MyBook.Close(saveChanges,_variant_t(strFilePath),covOptional);
	MyBook.ReleaseDispatch();
	MyBooks.Close();
	MyBooks.ReleaseDispatch();
	MyApp.Quit();
	MyApp.ReleaseDispatch();
	CoUninitialize();
}

MyFont::MyFont()
{
	//名字
	Name="Microsoft Sans Serif";
	//大小
	size=12;
	//前景
	ForeColor=RGB(0,0,0);
	//粗体
	Bold=FALSE;
	//斜体
	Italic=FALSE;
	//中间线
	Strikethrough=FALSE;
	//阴影
	Shadow=FALSE;
	//下标
	Subscript=FALSE;
	//上标
	Superscricp=FALSE;
	//下划线
	Underline=xlUnderlineStyleNone;	
}

MyBorder::MyBorder()
{
	//线条形状
	LineStyle=xlContinuous;
	//粗线
	Weight=xlThin;
	//颜色
	Color=RGB(0,0,0);
}

MyBackStyle::MyBackStyle()
{
	//背景颜色
	Color=RGB(255,255,255);
	//背景图案
	Pattern=xlSolid;
	//背景图案颜色
	PatternColor=RGB(255,0,0);
	//默认为不透明
	transparent=FALSE;
}

MyAlignment::MyAlignment()
{
	//普通
	HorizontalAlignment=xlGeneral;
	//居中对齐
	VerticalAlignment=xlCenter;
}

MyNumberFormat::MyNumberFormat()
{
	strValue="G/通用格式";
}

CString MyNumberFormat::GetText()
{
	strValue="@";
	return strValue;
}

CString MyNumberFormat::GetGeneral()
{
	strValue="G/通用格式";
	return strValue;
}

CString MyNumberFormat::GetNumber(BOOL blnBox,int RightSum)
{
	CString str="0";
	int i;
	if(RightSum<0) RightSum=0;
	if(blnBox==TRUE)
	{
		if(RightSum==0)
		{
			str="#,##0_ ";
			strValue=str;
			return strValue;
		}
		else
		{
			str="#,##0.";
			for(i=0;i<RightSum;i++) str=str+"0";
			str=str+"_ ";
			strValue=str;
			return strValue;	
		}
	}
	else
	{
		if(RightSum==0)
		{
			str="0_ ";
			strValue=str;
			return strValue;
		}
		else
		{
			str="0.";
			for(i=0;i<RightSum;i++) str=str+"0";
			str=str+"_ ";
			strValue=str;
			return strValue;	
		}
	}
}

CString MyNumberFormat::GetDate(BOOL blnChinese)
{
	if(blnChinese==TRUE)
		strValue="yyyy\"年\"m\"月\"d\"日\";@";
	else
		strValue="yyyy-m-d;@";
	return strValue;
}

CString MyNumberFormat::GetDateTime(BOOL blnChinese)
{
	if(blnChinese==TRUE)
		strValue="yyyy\"年\"m\"月\"d\"日\" h\"时\"mm\"分\"ss\"秒\";@";
	else
		strValue="yyyy-m-d h:mm:ss;@";
	return strValue;
}

CString MyNumberFormat::GetDBNumber(BOOL blnChinese)
{
	if(blnChinese==TRUE)
		strValue="[DBNum1][$-804]G/通用格式";
	else
		strValue="[DBNum2][$-804]G/通用格式";
	return strValue;
}

CString MyNumberFormat::GetFractionNumBer(int DownSum,int DownNum)
{	
	CString str;
	int i;
	if(DownNum>0 && DownSum>0)
	{
		AfxMessageBox(_T("分母位数和固定数只能设置一个,默认返回分母位数的设置!")
			,MB_ICONINFORMATION|MB_OK);
	}
	if(DownSum<=0)
	{
		if(DownNum<=0)
		{
			str="# ?/1";
			strValue=str;
			return strValue;
		}
		else
		{
			str.Format(_T("# ?/%d"),DownNum);
			strValue=str;
			return strValue;
		}
	}
	else
	{
		str="# ?/";
		for(i=0;i<DownSum;i++) str=str+"?";
		strValue=str;
		return strValue;
	}
}

CString MyNumberFormat::GetMoney(BOOL blnChinese,int RightSum)
{
	CString str;
	int i;
	if(RightSum<=0) RightSum=0;
	if(blnChinese==TRUE)
	{
		if(RightSum==0)
		{
			str="#,##0";
			strValue="￥"+str+";"+"￥-"+str;
			return strValue;
		}
		else
		{
			str="#,##0.";
			for(i=0;i<RightSum;i++) str=str+"0";
			strValue="￥"+str+";"+"￥-"+str;
			return strValue;
		}

	}
	else
	{
		if(RightSum==0)
		{
			str="#,##0";
			strValue="$"+str+";"+"$-"+str;
			return strValue;
		}
		else
		{
			str="#,##0.";
			for(i=0;i<RightSum;i++) str=str+"0";
			strValue="$"+str+";"+"$-"+str;
			return strValue;
		}
	}
}

CString MyNumberFormat::GetPercentNumBer(int RightSum)
{
	CString str;
	int i;
	if(RightSum<=0) RightSum=0;
	if(RightSum==0)
	{
		str="0%";
		strValue=str;
		return strValue;
	}
	else
	{
		str="0.";
		for(i=0;i<RightSum;i++) str=str+"0";
		strValue=str+"%";
		return strValue;
	}
}

CString MyNumberFormat::GetTechNumBer(int RightSum)
{
	CString str;
	int i;
	if(RightSum<=0) RightSum=0;
	str="0.";
	for(i=0;i<RightSum;i++) str=str+"0";
	strValue=str+"E+00";
	return strValue;
}

CString MyNumberFormat::GetTime(BOOL blnChinese)
{
	if(blnChinese==TRUE)
	{
		strValue="h\"时\"mm\"分\"ss\"秒\";@";
		return strValue;
	}
	else
	{
		strValue="h:mm:ss;@";
		return strValue;
	}
}

CString MyNumberFormat::GetPost(int Sum)
{
	int i;
	CString str="";
	if(Sum<=0) Sum=1;
	for(i=0;i<Sum;i++)
		str=str+"0";
	strValue=str;
	return strValue;
}

bool CExcelOperator::Add_Column(int column)
{
	LPDISPATCH lpDisp;
	char index = 'A' + column - 1 ;
	CString columC ;
	columC.Format(_T("%c"), index) ;
	columC += "1" ;
	lpDisp = WorkSheet.get_Range(COleVariant(columC),COleVariant(columC));
	ASSERT(lpDisp);
	MyRange.AttachDispatch(lpDisp);
	lpDisp = MyRange.get_EntireColumn() ;
	MyRange.AttachDispatch(lpDisp);
	MyRange.Insert(COleVariant((long)1));
	return true;
}
bool CExcelOperator::Delete_Column(int column)
{
	LPDISPATCH lpDisp;
	char index = 'A' + column - 1 ;
	CString columC ;
	columC.Format(_T("%c"), index) ;
	columC += "1" ;
	lpDisp = WorkSheet.get_Range(COleVariant(columC),COleVariant(columC));
	ASSERT(lpDisp);
	MyRange.AttachDispatch(lpDisp);
	lpDisp = MyRange.get_EntireColumn() ;
	MyRange.AttachDispatch(lpDisp);
	MyRange.Delete(COleVariant((long)1));
	return true;
}
bool CExcelOperator::Add_Row(int row)
{
	LPDISPATCH lpDisp;
	CString rowC ;
	rowC.Format(_T("%d"), row) ;
	rowC = "A" + rowC ;
	lpDisp = WorkSheet.get_Range(COleVariant(rowC),COleVariant(rowC));
	ASSERT(lpDisp);
	MyRange.AttachDispatch(lpDisp);
	lpDisp = MyRange.get_EntireRow() ;
	MyRange.AttachDispatch(lpDisp);
	MyRange.Insert(COleVariant((long)1));
	return true;
}
bool CExcelOperator::Delete_Row(int row)
{
	LPDISPATCH lpDisp;
	CString rowC ;
	rowC.Format(_T("%d"), row) ;
	rowC = "A" + rowC ;
	lpDisp = WorkSheet.get_Range(COleVariant(rowC),COleVariant(rowC));
	ASSERT(lpDisp);
	MyRange.AttachDispatch(lpDisp);
	lpDisp = MyRange.get_EntireRow() ;
	MyRange.AttachDispatch(lpDisp);
	MyRange.Delete(COleVariant((long)1));
	return true;
}

bool CExcelOperator::Get_Rows_Columns(int& nrow, int& ncolumn)
{
	nrow = GetRowS();
	ncolumn = GetColS();
	return true;
}

bool CExcelOperator::Write_Picture(const CString range1, const CString range2, const CString PicPath, bool clamp)
{
	COleVariant m_covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR); 
	CPicture pic;
	CPictures pics;
	CBorder border;

	pics = WorkSheet.Pictures(m_covOptional);
	// 	pics.Cut();

	MyRange = WorkSheet.get_Range(COleVariant(range1), COleVariant(range2));
	MyRange.Select ();
	//-----------------------------------------------------
	BOOL IFOK=IsFileExist(PicPath,FALSE);
	if (FALSE==IFOK)
		return false;
	//-----------------------------------------------------
	pic = pics.Insert (PicPath, m_covOptional);

	if (clamp)
	{
		double width = pic.get_Width() ;
		double height = pic.get_Height() ;
		double scale = width / height ;

		double width_range = MyRange.get_Width().dblVal ;
		double height_range = MyRange.get_Height().dblVal ;

		double height_res = width_range / scale ;
		double width_res ;
		if (height_res > height_range)
		{
			height_res = height_range ;
			width_res = height_range * scale ;
		}
		else
			width_res = width_range ;

		pic.put_Height(height_res) ;
		pic.put_Width(width_res) ;
	}
	MyRange.Show ();
	pic.ReleaseDispatch();
	pics.ReleaseDispatch();
	return true;
}

//--------------------------------------------------------
//功能：将一块区域内容复制到另外一块区域
//---------------------------------------------------------
void CExcelOperator::CopyToDestination(CString iBeginToCopy,CString iEndToCopy, CString iBeginDestination,CString iEndDestination)
{
	/*COleVariant m_covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);  //全局变量
	MyRange = WorkSheet.get_Range(COleVariant(iBeginToCopy),COleVariant(iEndToCopy)); 
	MyRange.Select(); 
	MyRange.Copy(m_covOptional); 

	CRange  CopyTo;
	CopyTo = WorkSheet.get_Range(COleVariant(iBeginDestination),COleVariant(iEndDestination)); 
	VARIANT vt2; 
	vt2.vt = VT_DISPATCH; 
	vt2.pdispVal = CopyTo.DetachDispatch(); 
	WorkSheet.Paste(vt2,m_covOptional); 
	CopyTo.ReleaseDispatch();*/

	CRange FromRange,ToRange;
	FromRange.AttachDispatch(WorkSheet.get_Range(_variant_t(iBeginToCopy),_variant_t(iEndToCopy)));
	ToRange.AttachDispatch(WorkSheet.get_Range(_variant_t(iBeginDestination),_variant_t(iEndDestination)));

	COleVariant varRange2;
	varRange2.vt = VT_DISPATCH;
	V_DISPATCH(&varRange2) = LPDISPATCH(ToRange);
	V_DISPATCH(&varRange2)->AddRef();

	FromRange.Copy(varRange2);

	FromRange.ReleaseDispatch();
	ToRange.ReleaseDispatch();

	//return true;

}
//--------------------------------------------------------
//功能：将制定Sheet中的制定区域内容及格式复制到当前Sheet的指定区域中
//---------------------------------------------------------
void CExcelOperator::CopyToDestinationFromNewSheet(int iSheet, CString iBeginToCopy,CString iEndToCopy, CString iBeginDestination,CString iEndDestination)
{
	COleVariant m_covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);  //全局变量
	CWorksheet AnotherSheet = GetSheet_CopyFrom(iSheet);
	CRange RangeCopyFrom = AnotherSheet.get_Range(COleVariant(iBeginToCopy),COleVariant(iEndToCopy)); 
	RangeCopyFrom.Copy(m_covOptional); 

	CRange  CopyTo;
	CopyTo = WorkSheet.get_Range(COleVariant(iBeginDestination),COleVariant(iEndDestination)); 
	VARIANT vt2; 
	vt2.vt = VT_DISPATCH; 
	vt2.pdispVal = CopyTo.DetachDispatch(); 
	WorkSheet.Paste(vt2,m_covOptional); 
	CopyTo.ReleaseDispatch();
	RangeCopyFrom.ReleaseDispatch();
}
//--------------------------------------------------------
//功能：取得指定Sheet
//---------------------------------------------------------
CWorksheet CExcelOperator::GetSheet_CopyFrom(int i)
{
	LPDISPATCH  lpDisp=NULL;
	long len;
	len=MySheets.get_Count();
	lpDisp=MySheets.get_Item((_variant_t)(long)i);
	CWorksheet SheetCopyFrom;
	SheetCopyFrom.AttachDispatch(lpDisp,TRUE);
	//lpDisp=SheetCopyFrom.get_Cells();
	//MyRange.AttachDispatch(lpDisp,TRUE);
	return SheetCopyFrom;
}
//--------------------------------------------------------
//功能：将制定Sheet中的已用行内容及格式复制到当前Sheet的指定区域中
//---------------------------------------------------------
void CExcelOperator::CopyUsedRowRangeToDestination(int iSheet, CString iBeginDestination,CString iEndDestination)
{
	COleVariant m_covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);  //全局变量
	CWorksheet AnotherSheet = GetSheet_CopyFrom(iSheet);
	CRange usedRange;
	CRange usedRowsRange;
	usedRange.AttachDispatch(AnotherSheet.get_UsedRange());//选取Sheet的可用区域
	usedRowsRange.AttachDispatch(usedRange.get_EntireRow());//按行选取区域，这样就能带格式复制了
	usedRowsRange.Copy(m_covOptional); 
	
	CRange  CopyTo;
	CopyTo = WorkSheet.get_Range(COleVariant(iBeginDestination),COleVariant(iEndDestination)); 
	VARIANT vt2; 
	vt2.vt = VT_DISPATCH; 
	vt2.pdispVal = CopyTo.DetachDispatch(); 
	WorkSheet.Paste(vt2,m_covOptional); 
	CopyTo.ReleaseDispatch();
	usedRowsRange.ReleaseDispatch();
}
//------------------------------------------------------------------------------------------------
///Function:    IndexToString  
///Description: 得到的单元格在EXCEL中的定位名称字符串  
///Input:       int row 单元格所在行  
// int col 单元格所在列  
///Return:      CString 单元格在EXCEL中的定位名称字符串  
//------------------------------------------------------------------------------------------------
CString CExcelOperator::IndexToString( int row, int col )   
{   
	CString strResult;  
	if( col > 26 )   
	{   
		strResult.Format(_T("%c%c%d"),'A' + (col-1)/26-1,'A' + (col-1)%26,row);  
	}   
	else   
	{   
		strResult.Format(_T("%c%d"), 'A' + (col-1)%26,row);  
	}   
	return strResult;  
}  


void CExcelOperator::SetCellHyperlinksToSheet(CString iCell,CString iLinksSheetName)
{
	CRange SelectRange;
	SelectRange.AttachDispatch(WorkSheet.get_Range(_variant_t(iCell),_variant_t(iCell)));

	CHyperlinks HyperLinks ;
	HyperLinks.AttachDispatch(WorkSheet.get_Hyperlinks());

	CString SheetLinkDef = iLinksSheetName+"!A1";
	HyperLinks.Add(SelectRange,L"",_variant_t(SheetLinkDef),_variant_t(iLinksSheetName),_variant_t(iLinksSheetName));



}

void CExcelOperator::DeleteAllSheets()
{
	long        sheetNum = 0;

	sheetNum = MySheets.get_Count();


	long nbSheet = sheetNum;
	for (int i=sheetNum;i>=1;i--)
	{
		if (nbSheet == 1)
		{
			break;
		}
		CWorksheet  tempSheet;
		tempSheet.AttachDispatch(MySheets.get_Item((_variant_t)(long)i),TRUE);
		//如果是sheet表是隐藏的话，就跳过，不做任何处理
		//删除的是当前的工作表
		if (WorkSheet.get_Name()==tempSheet.get_Name())
		{
			//将当前的工作表设为sheetName的前一张或是后一张表,(前一张优先)
			WorkSheet.AttachDispatch(MySheets.get_Item((_variant_t)(i==1?++i:--i)),TRUE);
			MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);
		}
		//设置系统不显示确认对话框，在操作Excel时，由于excel可能没有打开，
		//显示确认对话框可能出错
		MyApp.put_DisplayAlerts(FALSE);
		tempSheet.Delete();
		MyApp.put_DisplayAlerts(TRUE);

		nbSheet--;
		//tempSheet.ReleaseDispatch();
	}

	return ;
}

bool CExcelOperator::MergeUnits(const CString range1, const CString range2)
{
	CRange m_ExcelRange;
	m_ExcelRange.AttachDispatch(WorkSheet.get_Range(COleVariant(range1), COleVariant(range2)));
	m_ExcelRange.Merge(_variant_t(0));
	m_ExcelRange.ReleaseDispatch();
	return true;
}


void CExcelOperator::SetFont(CString iStartCell,CString iEndCell,CString iFontName)
{
	CRange UnitRge;
	
	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);

	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));
	CExcelFont f=UnitRge.get_Font();
	f.SetName(_variant_t(iFontName));
	f.ReleaseDispatch();
	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetFontSize(CString iStartCell,CString iEndCell,long iSize)
{
	CRange UnitRge;

	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);

	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));
	CExcelFont f=UnitRge.get_Font();
	f.SetSize(_variant_t(iSize));
	f.ReleaseDispatch();
	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetFontBold(CString iStartCell,CString iEndCell,BOOL iBold)
{
	CRange UnitRge;

	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);

	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));
	CExcelFont f=UnitRge.get_Font();
	f.SetBold(_variant_t(iBold));
	f.ReleaseDispatch();
	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetBorder(CString iStartCell,CString iEndCell,long iPos,long iStyle,long iWidth,int r,int g,int b)
{
	CRange UnitRge;
	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);
	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));

	CBorders Borders;
	Borders.AttachDispatch(UnitRge.get_Borders());
	CBorder DiagonalDownBorder;
	DiagonalDownBorder.AttachDispatch(Borders.get_Item(xlDiagonalDown));
	DiagonalDownBorder.put_LineStyle(_variant_t(xlNone));
	CBorder DiagonalUpBorder;
	DiagonalUpBorder.AttachDispatch(Borders.get_Item(xlDiagonalUp));
	DiagonalUpBorder.put_LineStyle(_variant_t(xlNone));

	if (iPos == xlAllSide)
	{
		for (int IndexOfSide = 7; IndexOfSide <= 12 ; IndexOfSide++)
		{
			CBorder CurBorder;
			CurBorder.AttachDispatch(Borders.get_Item(IndexOfSide));
			CurBorder.put_LineStyle(_variant_t(iStyle));
			CurBorder.put_Color(_variant_t(RGB(r,g,b)));
			CurBorder.put_Weight(_variant_t(iWidth));
			CurBorder.ReleaseDispatch();
		}
	}
	else if(iPos >= 5 && iPos <= 12)
	{
		CBorder CurBorder;
		CurBorder.AttachDispatch(Borders.get_Item(iPos));
		CurBorder.put_LineStyle(_variant_t(iStyle));
		CurBorder.put_Color(_variant_t(RGB(r,g,b)));
		CurBorder.put_Weight(_variant_t(iWidth));
		CurBorder.ReleaseDispatch();
	}

	UnitRge.ReleaseDispatch();
	Borders.ReleaseDispatch();
	DiagonalDownBorder.ReleaseDispatch();
	DiagonalUpBorder.ReleaseDispatch();
}

void CExcelOperator::SetColumnWidth(CString iCol,double iWidth)
{
	CRange UnitRge;
	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);

	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iCol),_variant_t(iCol)));
	UnitRge.put_ColumnWidth(_variant_t(iWidth));
	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetRowHeight(CString iRow,double iHeight)
{
	CRange UnitRge;
	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);

	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iRow),_variant_t(iRow)));
	UnitRge.put_RowHeight(_variant_t(iHeight));

	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetAlignment(CString iStartCell,CString iEndCell,MyAlignment myAlignment)
{
	CRange UnitRge;
	MyRange.AttachDispatch(WorkSheet.get_Cells(),TRUE);

	UnitRge.AttachDispatch(MyRange.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));
	UnitRge.put_HorizontalAlignment((_variant_t)(short)myAlignment.HorizontalAlignment);
	UnitRge.put_VerticalAlignment((_variant_t)(short)myAlignment.VerticalAlignment);
	
	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetTextWrap(CString iStartCell,CString iEndCell,BOOL iWrap)
{
	CRange UnitRge;
	UnitRge.AttachDispatch(WorkSheet.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));
	UnitRge.put_WrapText(_variant_t(iWrap));
	UnitRge.ReleaseDispatch();
}

void CExcelOperator::SetColAutoFit(CString iStartCell,CString iEndCell)
{
	CRange UnitRge;
	UnitRge.AttachDispatch(WorkSheet.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));

	CRange ColRge;
	ColRge.AttachDispatch(UnitRge.get_EntireColumn());
	ColRge.AutoFit();

	UnitRge.ReleaseDispatch();
	ColRge.ReleaseDispatch();

}


void CExcelOperator::SetRowAutoFit(CString iStartCell,CString iEndCell)
{
	CRange UnitRge;
	UnitRge.AttachDispatch(WorkSheet.get_Range(_variant_t(iStartCell),_variant_t(iEndCell)));

	CRange RowRge;
	RowRge.AttachDispatch(UnitRge.get_EntireRow());
	RowRge.AutoFit();

	UnitRge.ReleaseDispatch();
	RowRge.ReleaseDispatch();

}