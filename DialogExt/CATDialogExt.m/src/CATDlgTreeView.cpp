//===================================================================
// COPYRIGHT  2019/12/26
//===================================================================
// CATDlgTreeView.cpp
// Header definition of class CATDlgTreeView
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2019/12/26 Creation: Code generated by the 3DS wizard
//===================================================================

#ifdef _WINDOWS_
#undef _WINDOWS_
#endif

#define IDC_CAANODETREE 10001


#include "afxmt.h"
#include <afxcmn.h>
#include <string>
#include <vector>
#include <map>
//
#include "CATDlgTreeView.h"
#include "CATDialog.h"
//////////////////////////////////////////////////////////////////////////////////////////////////////tree

#include "TreeDbNotify.h"
#include "TreeLBNotify.h"
#include "TreeRBNotify.h"


//////////////////////////////////////////////////////////////////////////
char * wchar2char(const wchar_t* wchar)
{
	char * m_char;
	int len = WideCharToMultiByte(CP_ACP, 0, wchar, wcslen(wchar), NULL, 0, NULL, NULL);
	m_char = new char[len + 1];
	WideCharToMultiByte(CP_ACP, 0, wchar, wcslen(wchar), m_char, len, NULL, NULL);
	m_char[len] = '\0';
	return m_char;
}
class CATDlgNode::CATDlgNodeEmp
{
public:
	HTREEITEM	_treeNodeItem;
	int				  _type;
	CATUnicodeString _sName;
	std::vector<CATDlgNode*> _listChild;
	//
	void*	_void;
	int _state;		//1,UNCheck,2,Pass,3NotPass
	int tr,tg,tb;		//Text Color
	int bkr,bkg,bkb;
};

CATDlgNode::CATDlgNode(CATUnicodeString iName,int iType,void *iVoid)
{
	_ptr = new CATDlgNodeEmp;
	_ptr->_sName = iName;
	_ptr->_type = iType;
	_ptr->_void = iVoid;
	_ptr->_state = 0;
	_ptr->tr = -1;
	_ptr->tg = -1;
	_ptr->tb = -1;
}

void CATDlgNode::SetState(int i)
{
	_ptr->_state = i;
}

int CATDlgNode::GetState()
{
	return _ptr->_state;
}
void CATDlgNode::SetName(CATUnicodeString iName)
{
	if (!_ptr)
	{
		return;
	}
	_ptr->_sName = iName;
}
void CATDlgNode::SetType(int iType)
{
	if (!_ptr)
	{
		return;
	}
	_ptr->_type = iType;
}

CATUnicodeString CATDlgNode::GetName()
{
	if (!_ptr)
	{
		return "";
	}
	return _ptr->_sName;
}
int CATDlgNode::GetType()
{
	if (!_ptr)
	{
		return -1;
	}
	return _ptr->_type;
}

void CATDlgNode::AddNewChild(CATDlgNode *newChild)
{
	if (!_ptr)
	{
		return;
	}
	_ptr->_listChild.push_back(newChild);
}

//
void CATDlgNode::SetMember(void *iVoid)
{
	if (!_ptr)
	{
		return;
	}
	_ptr->_void = iVoid;
}

void *CATDlgNode::GetMember()
{
	if (!_ptr)
	{
		return 0;
	}
	return _ptr->_void;
}

int CATDlgNode::GetNbChild()
{
	if (!_ptr)
	{
		return 0;
	}
	return _ptr->_listChild.size();
}
CATDlgNode *CATDlgNode::GetChild(int i)
{
	if (!_ptr)
	{
		return 0;
	}
	return _ptr->_listChild[i];
}

void CATDlgNode::SetTextRGB(int r,int g,int b)
{
	_ptr->tr = r;
	_ptr->tg = g;
	_ptr->tb = b;

}

CATDlgNode * GetNodeByItem(CATDlgNode *pFatherNode, HTREEITEM hItem)
{
	CATDlgNode* retNode = NULL;
	if (pFatherNode)
	{
		if (pFatherNode->_ptr->_treeNodeItem == hItem)
		{
			retNode = pFatherNode;
		}
		else
		{
			for (int i = 0; i < pFatherNode->_ptr-> _listChild.size(); i++)
			{
				CATDlgNode * pNode = GetNodeByItem((pFatherNode->_ptr->_listChild[i]), hItem);
				if (pNode)
				{
					retNode = pNode;
					break;
				}
			}
		}
	}
	return retNode;
}


//

#define UM_CHECKSTATECHANGE (WM_USER + 100)

class CAAMfcTree : public CTreeCtrl
{
	DECLARE_DYNAMIC(CAAMfcTree);
    DECLARE_MESSAGE_MAP()

	//BEGIN_MESSAGE_MAP(CAAMfcTree,CWinApp)
	//	ON_WM_PAINT()
	//END_MESSAGE_MAP()
	enum
	{
		IDD = IDC_CAANODETREE
	};

public:
	//////////////////////////////////////////////////////////////////////////
	CAAMfcTree(CATDialog *ipBox/* CATDlgFrame,CATDlgContainer,...*/, CATUnicodeString sIconPath,const bool &iCheckBox=true)
	{
		_RootNode = NULL;
		_pDbNotify = NULL;
		_pLBtDownNotify = NULL;
		_pRBtDownNotify = NULL;
		if (ipBox)
		{
			HWND iFatherCtrl = (HWND)ipBox->GetWindowHandle();
			DRECT iFatherRECT;
			ipBox->GetRectDimensions(&iFatherRECT);
			CWnd *pFatherCWnd = CWnd::FromHandle(iFatherCtrl);
			if (pFatherCWnd != NULL)
			{
				if (iCheckBox)
				{
					this->Create(WS_VISIBLE | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_HASLINES | TVS_NOTOOLTIPS | TVS_CHECKBOXES | TVS_SHOWSELALWAYS,
						CRect(5, 5, iFatherRECT.dx-5, iFatherRECT.dy-5), pFatherCWnd, IDC_CAANODETREE);
				}
				else
				{
					this->Create(WS_VISIBLE | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_HASLINES | TVS_NOTOOLTIPS |TVS_SHOWSELALWAYS ,
						CRect(5, 5, iFatherRECT.dx-5, iFatherRECT.dy-5), pFatherCWnd, IDC_CAANODETREE);
				}
				//this->SetBkColor(RGB(242, 242, 242));

				//const char* pImgChar = sIconPath.ConvertToChar();
				//std::string strImg = pImgChar;
				//CString strImgMfc = strImg.c_str();

				//int len = WideCharToMultiByte(CP_ACP, 0, strImgMfc, strImgMfc.GetLength(), NULL, 0, NULL, NULL);
				//wchar_t *ptr;
				//ptr = strImgMfc.GetBuffer(len);

				//CBitmap *iconmap1 = new CBitmap();
				//iconmap1->Attach((HBITMAP)LoadImage(AfxGetInstanceHandle(), ptr, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE));
				//if (m_IconList.Create(24, 24, ILC_COLOR24, 2, 2))
				//{
				//	m_IconList.Add(iconmap1, RGB(0, 0, 0));
				//	this->SetImageList(&m_IconList, TVSIL_NORMAL);//TVSIL_STATE//TVSIL_NORMAL
				//}
			}
			_pCmd = ipBox;
		}
		
		//
		_pDbNotify = new TreeDbNotify();
		_pLBtDownNotify = new TreeLBNotify();
		_pRBtDownNotify = new TreeRBNotify();
	};
	//////////////////////////////////////////////////////////////////////////
	virtual ~CAAMfcTree()
	{
		delete _pDbNotify;
		delete _pLBtDownNotify;
		delete _pRBtDownNotify;
	};
	//////////////////////////////////////////////////////////////////////////
	void Init(CATDlgNode *iRootNode, HTREEITEM lparent = TVI_ROOT, HTREEITEM lpFont = TVI_LAST)
	{
		if (lparent == TVI_ROOT)
		{
			_RootNode = iRootNode;
		}
		InsertItemEx(iRootNode, lparent, lpFont);
		for (int iINd = 0; iINd < iRootNode->_ptr->_listChild.size(); iINd++)
		{
			CATDlgNode *childNode = (iRootNode->_ptr->_listChild[iINd]);
			Init(childNode, iRootNode->_ptr->_treeNodeItem);
		}
	};
	//////////////////////////////////////////////////////////////////////////
	CATDlgNode* GetSelectNode()
	{
		HTREEITEM hItem = this->GetSelectedItem();
		if (hItem == NULL)
		{
			return NULL;
		}
		return GetNodeByItem(_RootNode, hItem);
	};
	//////////////////////////////////////////////////////////////////////////
	CATDlgNode *GetParentNode(CATDlgNode *ipNode)
	{
		HTREEITEM hParentItem = GetParentItem(ipNode->_ptr->_treeNodeItem);
		return  GetNodeByItem(_RootNode, hParentItem);
	};
	void InsertChild(CATDlgNode* pFatherNode, CATDlgNode* pChildNode, int iPos = 1)//-1,first;other,last;
	{
		if (pFatherNode == NULL)
		{
			InsertItemEx(pChildNode, TVI_ROOT, TVI_LAST);
		}
		else
		{
			if (iPos == -1)
			{
				InsertItemEx(pChildNode, pFatherNode->_ptr->_treeNodeItem, TVI_FIRST);
			}
			else
			{
				InsertItemEx(pChildNode, pFatherNode->_ptr->_treeNodeItem, TVI_LAST);
			}
			pFatherNode->_ptr->_listChild.push_back(pChildNode);
		}
	};
	void DeleteChild(CATDlgNode* pChildNode)
	{
		if (pChildNode == NULL || pChildNode->_ptr->_treeNodeItem == _RootNode->_ptr->_treeNodeItem)
		{
			return;
		}
		else
		{
			HTREEITEM fatherItem = GetParentItem(pChildNode->_ptr->_treeNodeItem);
			CATDlgNode* pFatherNode = GetNodeByItem(_RootNode, fatherItem);
			for (int i = 0; i < pFatherNode->_ptr->_listChild.size(); i++)
			{
				if (pFatherNode->_ptr->_listChild[i]->_ptr->_treeNodeItem == pChildNode->_ptr->_treeNodeItem)
				{
					this->DeleteItem(pChildNode->_ptr->_treeNodeItem);
					pFatherNode->_ptr->_listChild.erase(pFatherNode->_ptr->_listChild.begin() + i);
					UpdateData();
					break;
				}
			}
		}
	};
	void UpdateNodeState(CATDlgNode *iNode)
	{
		if (iNode)
		{
			this->SetItemText(iNode->_ptr->_treeNodeItem, iNode->_ptr->_sName);
			this->SetItemImage(iNode->_ptr->_treeNodeItem, iNode->_ptr->_type, iNode->_ptr->_type);
			this->UpdateData();
		}
	};
    BOOL GetNodeCheckState(CATDlgNode *iNode)
    {
        if (iNode)
        {
            return this->GetCheck(iNode->_ptr->_treeNodeItem);
        }
        return FALSE;
    };
    void SetNodeCheckState(CATDlgNode *iNode, BOOL iState = TRUE)
    {
        if (iNode)
        {
            this->SetCheck(iNode->_ptr->_treeNodeItem, iState);
            SetChildCheck(iNode->_ptr->_treeNodeItem, iState);
			if(iState)
				this->Expand(iNode->_ptr->_treeNodeItem, TVE_EXPAND);//展开节点
        }
    };
	void test()
	{
		printf("");
	};
	void OnNMCustomdraw(NMHDR *pNMHDR, LRESULT *pResult)
	{
		printf("OnNMCustomdraw\n");
		LPNMTVCUSTOMDRAW pNMCD = reinterpret_cast<LPNMTVCUSTOMDRAW>(pNMHDR);
		CString s;
		switch (pNMCD->nmcd.dwDrawStage)
		{		
		case CDDS_PREPAINT:
			*pResult = CDRF_NOTIFYITEMDRAW;
			return;
		case CDDS_ITEMPREPAINT:
			// 这里做判断
			if (this->IsWindowEnabled() == 1)
			{
				if ((pNMCD->nmcd.uItemState & (CDIS_FOCUS)) == 0
					&& (pNMCD->nmcd.uItemState & (CDIS_SELECTED)) == CDIS_SELECTED) // selected
				{
					pNMCD->clrTextBk = RGB(0, 128, 220);  //失去焦点后被选项背景颜色
					pNMCD->clrText = RGB(255, 255, 255);  //失去焦点后被选项文本颜色
				}
				*pResult = CDRF_NOTIFYPOSTPAINT;
				return;
			}
			else {
				*pResult = CDRF_DODEFAULT;
				return;
			}

			break;
		default:
			break;
		}
		*pResult = 0;

	};


	afx_msg void OnPaint()
	{
		CPaintDC dc(this);
		CDC memDC;
		memDC.CreateCompatibleDC( &dc );
		CRect rcClip, rcClient;
		dc.GetClipBox( &rcClip );
		GetClientRect(&rcClient);
		CBitmap bitmap;
		bitmap.CreateCompatibleBitmap( &dc, rcClient.Width(), rcClient.Height() );
		memDC.SelectObject( &bitmap );
		CRgn rgn;
		rgn.CreateRectRgnIndirect( &rcClip );
		memDC.SelectClipRgn(&rgn);
		rgn.DeleteObject();
		CWnd::DefWindowProc( WM_PAINT, (WPARAM)memDC.m_hDC, 0 );

		//HTREEITEM CurSelectItem = this->GetSelectedItem();
		//int nbChild = _RootNode->GetNbChild();
		//for (int i = 0; i < nbChild; i++)
		//{
		//	CATDlgNode *pSetNode = _RootNode->GetChild(i);
		//	int nbItem = pSetNode->GetNbChild();
		//	for (int IndexOfItem = 0; IndexOfItem < nbItem ; IndexOfItem++)
		//	{
		//		CATDlgNode *pNode = pSetNode->GetChild(IndexOfItem);
		//		if (pNode->GetState() == 1)
		//		{
		//			//UNCheck
		//			//不修改颜色
		//		}
		//		else if (pNode->GetState() == 2)
		//		{
		//			
		//		}
		//		else if (pNode->GetState() == 3)
		//		{
		//			
		//		}
		//		else if (pNode->GetState() == 4)
		//		{
		//			//NotPass
		//			
		//		}


		//		if (pNode->_ptr->tr >=0
		//			&& pNode->_ptr->tg >=0
		//			&& pNode->_ptr->tb >= 0)
		//		{
		//			CFont *pFontDC;
		//			LOGFONT logfont;
		//			CFont *pFont = GetFont();
		//			pFont->GetLogFont(&logfont);
		//			CFont fontDC;
		//			fontDC.CreateFontIndirect(&logfont);
		//			pFontDC = memDC.SelectObject(&fontDC);
		//			COLORREF color = RGB(pNode->_ptr->tr, pNode->_ptr->tg, pNode->_ptr->tb);
		//			memDC.SetTextColor(color);
		//			//Just for test
		//			CRect rect;
		//			GetItemRect(pNode->_ptr->_treeNodeItem, &rect, TRUE);
		//			memDC.SetBkColor(GetSysColor(COLOR_WINDOW));
		//			CString sItem = GetItemText(pNode->_ptr->_treeNodeItem);
		//			memDC.TextOut(rect.left + 2, rect.top + 1, sItem);
		//			memDC.SelectObject(pFontDC);
		//		}
		//	}
		//	
		//}
		dc.BitBlt( rcClip.left, rcClip.top, rcClip.Width(), rcClip.Height(), &memDC,
			rcClip.left, rcClip.top, SRCCOPY );

	};

	void ResetNodeColor(const int &r,const int &g,const int &b)
	{
		HTREEITEM hRootItem = this->GetRootItem();
		if (this->ItemHasChildren(hRootItem))
		{
			_RootNode->SetTextRGB(r,g,b);
			HTREEITEM hSetItem = this->GetChildItem(hRootItem);
			CATDlgNode *pSetNode = GetNodeByItem(_RootNode,hRootItem);
			pSetNode->SetTextRGB(r,g,b);
			while(hSetItem != NULL)
			{
				if (this->ItemHasChildren(hSetItem))
				{
					HTREEITEM hCheckItem = this->GetChildItem(hSetItem);
					while(hCheckItem != NULL)
					{
						GetNodeByItem(pSetNode,hCheckItem)->SetTextRGB(r,g,b);
						hCheckItem = this->GetNextItem(hCheckItem,TVGN_NEXT);
					}
				}
				hSetItem = this->GetNextItem(hSetItem,TVGN_NEXT);
			}
		}
	}

	std::vector<CATDlgNode *> GetCheckedNode()
	{
		std::vector<CATDlgNode *> listOfCheckedNode;
		HTREEITEM hRootItem = this->GetRootItem();
		if (this->ItemHasChildren(hRootItem))
		{
			HTREEITEM hSetItem = this->GetChildItem(hRootItem);
			CATDlgNode *pSetNode = GetNodeByItem(_RootNode,hRootItem);
			while(hSetItem != NULL)
			{
				if (this->ItemHasChildren(hSetItem))
				{
					HTREEITEM hCheckItem = this->GetChildItem(hSetItem);
					while(hCheckItem != NULL)
					{
						if (this->GetCheck(hCheckItem))
						{
							listOfCheckedNode.push_back(GetNodeByItem(pSetNode,hCheckItem));
						}
						hCheckItem = this->GetNextItem(hCheckItem,TVGN_NEXT);
					}
				}
				hSetItem = this->GetNextItem(hSetItem,TVGN_NEXT);
			}
		}
		return listOfCheckedNode;
	}

	void Refresh()
	{
		this->Invalidate();
	}

	void OnKillFocus(CWnd *pNewWnd)
	{
		CTreeCtrl::OnKillFocus(pNewWnd);
		RedrawWindow();
	}
	CATDlgNode *GetRootNode(){return _RootNode;}
private:
	HTREEITEM SetMouseSelectNode()
	{
		CPoint oPoint;
		UINT nFlag;
		GetCursorPos(&oPoint);
		this->ScreenToClient(&oPoint);
		HTREEITEM hItem = this->HitTest(oPoint, &nFlag);
		if (nFlag==2 || nFlag == 4 )
		{
			this->SelectItem(hItem);
		}
		return hItem;
	};
	BOOL PreTranslateMessage(MSG* pMsg)
	{
		BOOL reValue = FALSE;
		switch (pMsg->message)
		{
		case WM_LBUTTONDBLCLK:
		{
			HTREEITEM selItem = SetMouseSelectNode();
			reValue = TRUE;
			reValue = CTreeCtrl::PreTranslateMessage(pMsg);
			if (selItem)
			{
				_pCmd->SendNotification(_pCmd, _pDbNotify);
			}
		}
		break;
		case WM_LBUTTONDOWN:
		{
			HTREEITEM selItem = SetMouseSelectNode();
			reValue = TRUE;
			reValue = CTreeCtrl::PreTranslateMessage(pMsg);
            CPoint point;
            UINT uFlag;
            GetCursorPos(&point);
            ScreenToClient(&point);
            HTREEITEM hItem = this->HitTest(point, &uFlag);
            if (selItem && (TVHT_ONITEMSTATEICON & uFlag))
            {
                // 发送消息，在进行父节点和子节点关联之前判断CheckBox前后的状态
                PostMessage(UM_CHECKSTATECHANGE, 0, (LPARAM)selItem);
            }
			else if (selItem && (TVHT_ONITEMBUTTON & uFlag))
			{
				//点击加减号
				//todo
			}
			else if (selItem)
			{
				_pCmd->SendNotification(_pCmd, _pLBtDownNotify);
			}
		}
		break;
		case WM_RBUTTONDOWN:
		{
			HTREEITEM selItem= SetMouseSelectNode();
			reValue = TRUE;
			reValue = CTreeCtrl::PreTranslateMessage(pMsg);
			if (selItem)
			{
				_pCmd->SendNotification(_pCmd, _pRBtDownNotify);
			}
		}
		break;
		default:
			reValue = CTreeCtrl::PreTranslateMessage(pMsg);
			break;
		}
		return reValue;
	};
    BOOL SetParentChildNodeCheck(HTREEITEM hItem, BOOL bCheck)
    {
        if (hItem == NULL)
            return FALSE;
        HTREEITEM hChild = this->GetChildItem(hItem);
        SetChildCheck(hChild, bCheck);
        return TRUE;
    }
    void SetChildCheck(HTREEITEM hItem, BOOL bCheck)
    {
        if (hItem == NULL) return;

        this->SetCheck(hItem, bCheck);

        HTREEITEM hSibling = this->GetNextItem(hItem, TVGN_NEXT);
        while (hSibling)
        {
            this->SetCheck(hSibling, bCheck);
            HTREEITEM hSibChild = this->GetChildItem(hSibling);
            if (hSibChild)
            {
                SetChildCheck(hSibChild, bCheck);
            }
            hSibling = this->GetNextItem(hSibling, TVGN_NEXT);
        }
        HTREEITEM hChild = this->GetChildItem(hItem);
        if (hChild != NULL)
        {
            SetChildCheck(hChild, bCheck);
        }
    }
    afx_msg LRESULT OnCheckMessage(WPARAM wParam, LPARAM lParam)
    {
        HTREEITEM hItem = (HTREEITEM)lParam;
        BOOL bCheck = this->GetCheck(hItem);
        SetParentChildNodeCheck(hItem, !bCheck);
        return 0L;
    };
	void InsertItemEx(CATDlgNode *iNewNode, HTREEITEM lparent = TVI_ROOT, HTREEITEM lpFont = TVI_LAST)
	{
		if (iNewNode)
		{
			CATUnicodeString iNodeName = iNewNode->_ptr->_sName;
			int iType = iNewNode->_ptr->_type;
			//
			wchar_t *iInsertItemStr = new wchar_t[iNodeName.GetLengthInChar() + 1];
			iNodeName.ConvertToWChar(iInsertItemStr);
			HTREEITEM	newItem = this->InsertItem(iInsertItemStr, iType, iType, lparent, lpFont);
			//
			iNewNode->_ptr->_treeNodeItem = newItem;
		}
	};


//
public:
	TreeDbNotify *_pDbNotify;
	TreeLBNotify * _pLBtDownNotify;
	TreeRBNotify * _pRBtDownNotify;
	//
private:
	CATCommand *_pCmd;
	CATDlgNode *_RootNode;
	CImageList m_IconList;
	//////////////////////////////////////////////////////////////////////////
};
BEGIN_MESSAGE_MAP(CAAMfcTree, CTreeCtrl)
	ON_MESSAGE(UM_CHECKSTATECHANGE, &CAAMfcTree::OnCheckMessage)
END_MESSAGE_MAP()
IMPLEMENT_DYNAMIC(CAAMfcTree, CTreeCtrl)

class CATDlgTreeView::CATDlgTreeViewEmp
{
public:
	CAAMfcTree * _pCAAMfcTree;
};

#include "CATListOfCATUnicodeString.h"
int StringToVector(const CATUnicodeString &iStr, const CATUnicodeString &iSplit, CATLISTV(CATUnicodeString) &oStrVector)
{
	int num = 0;
	//Clear Vector
	oStrVector.RemoveAll();

	if (iSplit != "" && iStr != "")
	{
		CATUnicodeString aStr(iStr);
		int nStrLen = aStr.GetLengthInChar();
		int nSplitLen = iSplit.GetLengthInChar();

		CATUnicodeString subStr = "";
		int nIndex = aStr.SearchSubString(iSplit, 0);
		while (nIndex >= 0)
		{
			subStr = aStr.SubString(0, nIndex);
			oStrVector.Append(subStr);
			num++;
			aStr = aStr.SubString(nIndex + nSplitLen, nStrLen - nIndex - nSplitLen);
			nStrLen = aStr.GetLengthInChar();
			nIndex = aStr.SearchSubString(iSplit, 0);
		}
		if (aStr != "")
		{
			oStrVector.Append(aStr);
			num++;
		}
	}
	return num;
}
#include "CATGetEnvValue.h"
CATUnicodeString GetEnvValue(CATUnicodeString iEnvName)
{
	CATUnicodeString sEnvValue = "";
	char * envname = (char *)iEnvName.ConvertToChar();
	char * envvalue = "";
	CATGetEnvValue(envname, &envvalue);
	sEnvValue = envvalue;
	return sEnvValue;
}

CATUnicodeString GetFileFullPath(CATUnicodeString isFileName)
{
	CATUnicodeString sPhicPathc = GetEnvValue("CATGraphicPath");
	CATLISTV(CATUnicodeString)  listPath;
	StringToVector(sPhicPathc, ";", listPath);
	for (int i = 1; i <= listPath.Size(); i++)
	{
		CATUnicodeString sPath = listPath[i]+"\\" + isFileName;
		if (access(sPath, 0) != -1)
		{
			return sPath;
		}
		else
		{
			CATUnicodeString sPath = listPath[i] + "\\" + isFileName+".bmp";
			if (access(sPath, 0) != -1)
			{
				return sPath;
			}
		}
	}
	return "";
}

//////////////////////////////////////////////////////////////////////////
 CATDlgTreeView::CATDlgTreeView(CATDialog *iParent, CATUnicodeString iIcon,const bool &iCheckBox):_ptr(NULL)
 {
	 CATUnicodeString sGrphicS= GetFileFullPath(iIcon);	 
	 _ptr = new  CATDlgTreeViewEmp;
	 _ptr->_pCAAMfcTree= new CAAMfcTree(iParent, sGrphicS,iCheckBox);
	 _ptr->_pCAAMfcTree->test();
 }
// // // 
 CATDlgTreeView::~CATDlgTreeView()
 {
	 if (_ptr)
	 {
		 delete _ptr;
		 _ptr = NULL;
	 }
 }
 void CATDlgTreeView::Init(CATDlgNode *iRootNode)
 {
	 _ptr->_pCAAMfcTree->Init(iRootNode);
 }
 CATDlgNode *CATDlgTreeView::GetSelectNode()
 {
 	return (CATDlgNode *)_ptr->_pCAAMfcTree->GetSelectNode();
 }
 CATDlgNode *CATDlgTreeView::GetParentNode(CATDlgNode *ipNode)
 {
 	return  (CATDlgNode *)_ptr->_pCAAMfcTree->GetParentNode(ipNode);
 }
 CATDlgNode *CATDlgTreeView::GetRootNode()
 {
	 return (CATDlgNode *)_ptr->_pCAAMfcTree->GetRootNode();
 }
 BOOL CATDlgTreeView::GetNodeCheckState(CATDlgNode *iNode)
 {
     return _ptr->_pCAAMfcTree->GetNodeCheckState(iNode);
 }
 void CATDlgTreeView::SetNodeCheckState(CATDlgNode *iNode, BOOL iState)
 {
     return _ptr->_pCAAMfcTree->SetNodeCheckState(iNode, iState);
 }
// 
 void CATDlgTreeView::InsertChild(CATDlgNode* pFatherNode, CATDlgNode* pChildNode, int iPos)
 {
	 _ptr->_pCAAMfcTree->InsertChild(pFatherNode, pChildNode, iPos);
 }
 void CATDlgTreeView::DeleteChild(CATDlgNode* pChildNode)
 {
	 _ptr->_pCAAMfcTree->DeleteChild(pChildNode);
 }
 void CATDlgTreeView::UpdateNodeState(CATDlgNode *iNode)
 {
	 _ptr->_pCAAMfcTree->UpdateNodeState(iNode);
 }
 void CATDlgTreeView::Expand(CATDlgNode *iNode)
 {
	 _ptr->_pCAAMfcTree->Expand(iNode->_ptr->_treeNodeItem,TVE_EXPAND);

 }
// //																				  
 CATNotification * CATDlgTreeView::GetNodeDbNotification()
 {
 	return  _ptr->_pCAAMfcTree->_pDbNotify;
 }
 CATNotification * CATDlgTreeView::GetTreeLButtonNotification()
 {
	 return  _ptr->_pCAAMfcTree->_pLBtDownNotify;
 }
 CATNotification * CATDlgTreeView::GetTreeRButtonNotification()
 {
 	return  _ptr->_pCAAMfcTree->_pRBtDownNotify;
 }

 void CATDlgTreeView::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint)
 {
	  _ptr->_pCAAMfcTree->MoveWindow(x,y,nWidth,nHeight,bRepaint);

 }

 std::vector<CATDlgNode *> CATDlgTreeView::GetCheckedNode()
 {
	 return _ptr->_pCAAMfcTree->GetCheckedNode();
 }

 void CATDlgTreeView::ResetNodeColor(const int &r,const int &g,const int &b)
 {
	 _ptr->_pCAAMfcTree->ResetNodeColor(r,g,b);
 }

 void CATDlgTreeView::Refresh()
 {
	 _ptr->_pCAAMfcTree->Refresh();
 }

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
